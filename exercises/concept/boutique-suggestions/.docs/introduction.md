Comprehensions provide a facility for transforming _Enumerables_ easily and declaratively.

To declare a very simple comprehension, we can use the `for` keyword followed by a _generator_ and a _do-block_ which creates the new values from the enumerated values.

```elixir
for n <- [0, 1, 2, 3], do: n + 1
# => [1, 2, 3, 4]
```

Comprehensions can also have _filters_. Values that do not pass the filter are removed from the final list:

```elixir
for n <- [0, 1, 2, 3], n > 1, do: n + 1
# => [3, 4]
```

We can declare more complicated comprehensions over several lines:

```elixir
for {atom, number} <- [a: 1, b: 2, c: 3, d: 4],
    rem(number, 2) == 0 do
  atom
end
# => [:b, :d]
```

A _cartesian product_ can be created using multiple generators. That means that each value generated by the first generator will be paired once with each value generated by the second generator:

```elixir
for x <- [0, 1],
    y <- [0, 1] do
  {x, y}
end
# => [{0, 0}, {0, 1}, {1, 0}, {1, 1}]
```

[Comprehension][for] provide a facility for transforming _Enumerables_ easily and declaratively. They are _syntactic sugar_ for iterating through enumerables in Elixir.

```elixir
for s <- ["a", "b", "hello", "c"], # 1. generator
  String.length(s) == 1, # 2. filter
  into: "", # 3. collectable
  do: String.upcase(s)

# => "ABC"
```

There are three parts to a comprehension:

1. _generators_:
   - Values enumerated from structures that implement the [_Enumerable_][enumerable] protocol.
   - Pattern matching expressions to destructure enumerated values.
2. _filters_: Boolean conditions, used to select which enumerated values to use when creating the new values.
3. _collectables_: A structure which implements the [_Collectable_][collectable] protocol, used to collect the new values.

There are single- and multi-line comprehensions. When more than one generator is used, a [cartesian product][cartesian-product] of the values generated is enumerated. That means that each value generated by the first generator will be paired once with each value generated by the second generator.

```elixir
for n <- [0, 1, 2, 3], do: n + 1
# => [1, 2, 3, 4]

for x <- [0, 1],
    y <- [0, 1] do
  {x, y}
end
# => [{0, 0}, {0, 1}, {1, 0}, {1, 1}]
```

The value in the do-block is inserted into the _collectable_ **for each value generated** from the _enumerable_. It may or may not include variables bound inside of the comprehension.

```elixir
for _ <- [1, 2, 3], do: :a
# => [:a, :a, :a]
```

Pattern matching can occur in the comprehension, either on the left side of the `<-` or on their own line.

```elixir
for {atom, str} <- [a: "string"], do: str
# => ["string"]

for pair <- [a: "string"],
    {atom, str} = pair do
  str
end
# => ["string"]
```

[for]: https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1
[collectable]: https://hexdocs.pm/elixir/Collectable.html
[enumerable]: https://hexdocs.pm/elixir/Enumerable.html
[cartesian-product]: https://en.wikipedia.org/wiki/Cartesian_product
